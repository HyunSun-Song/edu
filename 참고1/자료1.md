### A고객사 시스템의 채널 확대 및 사용자 증가에 따라 발생하는 인증 및 세션 관리 문제 해결을 위한 인증 방식 개선 방안을 제시

<전제 조건>

•Session timeout : 30분

•중복 로그인 : 허용하지 않음

1. 사용자 증가에 따른 인증 관리 쳬계의 분담을 줄이기 위한 방안을 고안하고 설계하시오

   \- 각 서비스는 고객 증가 또는 인증 서비스의 장애 요인에 영향을 받지 않아야 한다.

2. B2B 고객을 위한 제로 트러스트 인증 방식에 대한 프로세스를 설계하시오

3. 중복 로그인 배재를 위한 방안을 제안하고 프로세스를 설계하시오

4. 인증방식의 전환에 따른 방안을 제시하고 프로세스를 설계하시오

5.  인증 불일치 또는 Session 만료에 따른 처리에 대한 UI 처리 방안을 설계하시오

###### 해당 문제를 해결하기 위한 인증 방식 개선 방안 및 프로세스 설계는 다음과 같습니다.

사용자 증가에 따른 인증 관리 분담을 줄이기 위한 방안:

서비스를 분산하여 로드 밸런싱을 통해 인증 및 세션 관리 서버의 부하를 분산시킴으로써 각 서비스가 고객 증가에 영향을 받지 않도록 설계합니다.
B2B 고객을 위한 제로 트러스트 인증 방식 프로세스:

B2B 고객을 위한 제로 트러스트 인증 방식은 사용자의 인증을 위해 신뢰할 수 있는 외부 인증 공급업체와의 연동을 통해 안전한 인증 절차를 보장합니다. B2B 고객은 외부 인증 공급업체를 통해 토큰 또는 인증 정보를 발급받아 시스템에 접속하게 됩니다.
중복 로그인 배재를 위한 방안 및 프로세스:

사용자의 중복 로그인을 허용하지 않기 위해, 한 계정으로 동시에 로그인할 수 없도록 처리합니다. 이를 위해 로그인 시 기존 세션을 해제하고 새로운 로그인 세션을 생성하도록 설계합니다.
인증방식의 전환에 따른 방안 및 프로세스:

새로운 인증 방식으로의 전환 시, 사용자들에게 충분한 예고 기간을 제공하고, 기존 사용자들의 편의성을 위해 이전 방식의 인증 정보를 새로운 방식으로의 전환을 유도하는 기간을 마련하며, 유저 교육 및 테스트 기간을 제공합니다.
인증 불일치 또는 Session 만료에 따른 UI 처리 방안:

사용자에게 인증 불일치 또는 세션 만료 시에는 명확하고 사용자가 이해하기 쉬운 알림을 제공합니다. 또한, 인증 불일치로 인한 문제가 발생한 경우에는 안내 메시지를 통해 사용자가 필요한 조치를 이해하고 취할 수 있도록 UI를 설계합니다.
이러한 방안과 프로세스를 통해 사용자 증가 및 인증 관리의 문제를 개선하고, 고객 서비스 품질을 유지하며 보증할 수 있습니다.

###### A고객사 시스템의 채널 확대 및 사용자 증가에 따라 발생하는 인증 및 세션 관리 문제를 해결하기 위해 아래와 같은 개선 방안을 제시합니다.

1. 사용자 증가에 따른 인증 관리의 분담을 줄이기 위한 방안
1.1. 분산 아키텍처

로드 밸런서를 도입하여 여러 인증 서버로 트래픽을 분산시킵니다. 이를 통해 단일 서버의 과부하를 방지하고, 시스템 안정성을 높입니다.
**오토스케일링 (Auto Scaling)**을 활용하여 사용자 증가에 따라 서버 자원을 동적으로 할당합니다. 이는 클라우드 환경에서 쉽게 구현할 수 있습니다.
1.2. API 게이트웨이

API 게이트웨이를 통해 인증 요청을 관리하고 조율합니다. 이를 통해 각 서비스는 독립적으로 운영되며 인증 서비스의 장애에도 영향을 받지 않습니다.
1.3. 캐싱 및 세션 스토리지 최적화

Redis와 같은 분산 캐시 시스템을 활용하여 세션 데이터를 관리합니다. 이를 통해 각 서버가 세션 데이터를 공유하여 확장성과 신뢰성을 보장합니다.
2. B2B 고객을 위한 제로 트러스트 인증 방식 프로세스
2.1. 제로 트러스트 원칙 구현

검증된 신원 확인: 모든 인증 요청에서 사용자의 신원을 철저히 확인합니다.
최소 권한 원칙 적용: 사용자 및 애플리케이션에 최소한의 접근 권한만 부여합니다.
연속 인증: 지속적으로 사용자 및 디바이스 상태를 모니터링하여 이상 활동을 탐지합니다.
2.2. 인증 프로세스

신원 증명: 디바이스와 사용자가 신뢰할 수 있는 인증 공급업체를 통해 신원 증명을 수행합니다.
인증 요청: 인증 요청 시, 백엔드 서버는 인증 공급업체 API를 호출하여 신원을 검증합니다.
토큰 발급: 신원이 검증된 사용자에게 JWT나 OAuth 토큰을 발급합니다.
자원 접근: 사용자가 자원 접근 시마다 토큰 유효성을 체크하여 접근을 승인합니다.

3. 중복 로그인 배제 방안 및 프로세스 설계
3.1. 단일 세션 정책
사용자가 새로운 디바이스에서 로그인을 시도할 경우, 기존 세션을 무효화하고 새로운 세션을 생성합니다.
이를 위해 세션 관리 테이블에 사용자 ID와 세션 ID 매핑을 유지합니다.

3.2. 세션 관리 프로세스
로그인 요청: 사용자가 로그인 요청을 보냅니다.
기존 세션 확인: 기존 세션이 존재할 경우 해당 세션을 무효화 (만료)합니다.
새 세션 생성: 새로운 세션을 생성하고 세션 ID를 저장합니다.
사용자 알림: 기존 세션이 만료되었음을 사용자에게 알립니다.

4. 인증방식의 전환 방안 및 프로세스 설계
4.1. 단계적 전환
기존 인증 방식과 새로운 인증 방식을 병행하여 전환 기간 동안 사용자에게 적응 시간을 제공합니다.
점진적으로 새로운 인증 방식을 도입하며, 전환 완료 시 기존 방식을 완전히 폐기합니다.

4.2. 전환 프로세스
준비 단계: 새로운 인증 시스템을 개발 및 테스트하고, 사용자에게 전환 계획을 공지합니다.
병행 운영: 두 인증 방식을 병행하여 지원합니다.
사용자 교육: 새로운 인증 방식 사용법을 사용자에게 교육 및 안내합니다.
전체 전환: 전환 기간 종료 후, 새로운 인증 방식으로 완전히 전환합니다.

5. 인증 불일치 또는 세션 만료에 따른 UI 처리 방안
5.1. 사용자 친화적 알림 제공

인증 불일치 또는 세션 만료 시 사용자에게 적절한 메시지를 알림창으로 표시합니다.
예시: "인증 세션이 만료되었습니다. 다시 로그인해 주세요."

5.2. 자동 로그아웃 및 재로그인 지원
세션 만료 시, 자동으로 로그아웃시키고 로그인 화면으로 리다이렉트합니다.
로그아웃 시 마무리되지 않은 작업이 있을 경우 이를 저장하거나 복구할 수 있는 옵션을 제공합니다.

5.3. 에러 페이지 디자인
인증 실패 시 사용자가 이해하기 쉽도록 에러 페이지를 디자인하여 필요한 조치를 설명합니다.
예시: "인증 과정에서 문제가 발생했습니다. 다시 시도해보세요."
이와 같은 방법들을 통해 A고객사의 시스템의 채널 확대 및 사용자 증가에 대비한 인증 및 세션 관리 문제를 효과적으로 해결할 수 있을 것입니다.

### A고객사 비즈니스 유연성과 성능 관점에서 상품을 관리하기 위한 데이터 모델을 새롭게 설계하고 설계 사유제시

<전제 조건>

•상황에 따른 ERD제공 됨

1. 예약 위주의 상품 관련 데이터 모델에 실시간 판매 가능한 상품 유형을 추가 하기 위한 방안을 제안하고 설계 하시오

2.  자사 직접 판매 상품뿐만 아닌 입점 업체애 대한 상품 주문 관련 서비스 모델을 설계 하시오

3.  상품 주문 절차에 대한 프로세스를 설계 하시오 

4.  상품 출시에 대한 라이프 사이클을 관리 하는 모델을 제시하고 설계 사유를 제시하시오

5. 특정 상품에 대한 옵션별 관리 방안에 대한 모델을 제시하시오

###### 각 항목에 대한 설계 사유와 함께 데이터 모델을 새롭게 설계해 보겠습니다.

1. 예약 위주의 상품 관련 데이터 모델에 실시간 판매 가능한 상품 유형을 추가하기 위한 방안
설계 사유:
예약 위주의 상품에 실시간 판매 가능한 상품 유형을 추가하여 실시간 예약 및 판매가 가능하도록 하고, 고객에게 유연한 서비스 제공을 목적으로 한다.

데이터 모델 설계:

기존 데이터 모델에 "실시간 판매 가능 여부"를 나타내는 필드를 추가한다.
이를 통해 예약 상품 중에서 실시간으로 호/예약 가능한 상품을 식별하고 관리할 수 있도록 한다.

2. 자사 직접 판매 상품뿐만 아닌 입점 업체에 대한 상품 주문 관련 서비스 모델
설계 사유:

자사 직접 판매 상품 뿐만 아니라 입점 업체의 상품 주문에 대한 관리를 위해 별도의 서비스 모델을 도입한다.
데이터 모델 설계:

"주문"과 "상품" 테이블에 입점 업체 관련 정보를 추가하고, 각 입점 업체의 상품 주문을 관리할 수 있도록 한다.
관리상 효율적인 데이터 구조로, 상품의 판매 유형(자사 직접, 입점 업체 등)을 명확히 구분하여 처리한다.

3. 상품 주문 절차에 대한 프로세스
설계 사유:

고객의 상품 주문 절차를 체계적으로 관리하고 투명하게 제시하여 구매 과정을 효율화한다.
데이터 모델 설계:

"주문" 정보를 관리하는 테이블에 주문 관련 정보를 상세하게 기록한다.
주문 단계에 따른 주문 상태를 업데이트할 수 있는 방안을 도입하여 주문 처리 과정을 체계화한다.

4. 상품 출시에 대한 라이프 사이클을 관리하는 모델
설계 사유:

라이프 사이클을 관리함으로써 신상품 출시, 품절상품 관리 등의 효율적 관리 및 예측이 가능하도록 한다.
데이터 모델 설계:

"상품" 테이블에 라이프 사이클과 관련된 정보를 추가하여, 출시일, 종료일, 상태 등을 체계적으로 관리한다.
해당 정보에 따라 신상품, 재고 관리 등에 유용한 분석을 제공한다.

5. 특정 상품에 대한 옵션별 관리 방안에 대한 모델
설계 사유:

특정 상품의 다양한 옵션 관리를 효율적으로 하기 위해 별도의 데이터 모델을 구성
데이터 모델 설계:

"상품 옵션" 테이블을 새로 추가하여 각 상품의 옵션 정보(색상, 사이즈 등)를 세부적으로 기록한다.
상품과 옵션 테이블을 조인하여, 특정 상품의 옵션별 재고, 가격, 판매여부 등을 명확하게 관리한다.
위와 같은 데이터 모델 설계를 통해 A고객사의 비즈니스 유연성과 성능 관점에서 상품을 효율적으로 관리할 수 있습니다.

###### A고객사의 비즈니스 유연성과 성능을 고려한 데이터 모델 설계는 서비스 확장성과 관리의 용이성을 목표로 합니다. 아래의 설계와 설계 사유를 제시하겠습니다. 전제 조건으로 제공된 ERD를 참고하여 상황에 맞게 보완하겠습니다.

1. 예약 위주의 상품 관련 데이터 모델에 실시간 판매 가능한 상품 유형을 추가하기 위한 방안
설계 사유:

현재 예약이 가능한 상품에 실시간 판매가 가능한 상품 유형을 추가하여, 예약 외에도 즉시 구매가 가능한 상품을 관리.
데이터 모델 설계:

sql 

CREATE TABLE Product (
    product_id INT PRIMARY KEY,
    name VARCHAR(255),
    description TEXT,
    price DECIMAL(10,2),
    is_real_time_available BOOLEAN DEFAULT FALSE, -- 실시간 판매 가능 여부 추가
    stock INT DEFAULT 0, -- 실시간 판매를 위한 재고 변수를 추가
    category_id INT
);

CREATE TABLE Reservation (
    reservation_id INT PRIMARY KEY,
    product_id INT,
    customer_id INT,
    reservation_date DATETIME,
    status VARCHAR(50),
    FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

2. 자사 직접 판매 상품뿐만 아닌 입점 업체에 대한 상품 주문 관련 서비스 모델
설계 사유:

자사 상품 외에도 입점 업체의 상품에 대한 주문을 통합 관리.
데이터 모델 설계:

sql 

CREATE TABLE Vendor (
    vendor_id INT PRIMARY KEY,
    name VARCHAR(255),
    contact_info TEXT
);

CREATE TABLE Product (
    product_id INT PRIMARY KEY,
    name VARCHAR(255),
    description TEXT,
    price DECIMAL(10,2),
    stock INT,
    category_id INT,
    vendor_id INT, -- 입점 업체 ID 추가
    is_real_time_available BOOLEAN DEFAULT FALSE, -- 실시간 판매 가능 여부
    FOREIGN KEY (vendor_id) REFERENCES Vendor(vendor_id)
);

CREATE TABLE Order (
    order_id INT PRIMARY KEY,
    product_id INT,
    customer_id INT,
    order_date DATETIME,
    quantity INT,
    status VARCHAR(50),
    FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

3. 상품 주문 절차에 대한 프로세스
설계 사유:

주문 절차를 체계적으로 관리하여 신속하고 정확한 주문 처리가 가능하게 함.
프로세스 설계:

고객이 상품을 선택 (Product 테이블).
주문 요청이 생성 새 주문이 생성(Order 테이블에 insert).
재고 확인 (Product 테이블에서 stock 확인).
결제 처리 (실제 결제 시스템과 연동 필요).
주문 상태 업데이트 (Order 테이블에서 status 업데이트).
재고 조정 (Product 테이블에서 stock 감소).

4. 상품 출시에 대한 라이프 사이클을 관리하는 모델
설계 사유:

상품의 출시, 판매, 종료 등의 주기를 명확히 관리함으로써 상품 관리의 유연성을 높임.
데이터 모델 설계:

sql 

CREATE TABLE Product_Lifecycle (
    product_id INT,
    status VARCHAR(50), -- ex. 'new', 'active', 'discontinued'
    start_date DATETIME,
    end_date DATETIME,
    FOREIGN KEY (product_id) REFERENCES Product(product_id)
);

5. 특정 상품에 대한 옵션별 관리 방안
설계 사유:

상품 하나에 대해 여러 옵션(색상, 크기 등을)을 체계적으로 관리할 필요.
데이터 모델 설계:

sql 

CREATE TABLE Product (
    product_id INT PRIMARY KEY,
    name VARCHAR(255),
    description TEXT,
    price DECIMAL(10,2),
    stock INT,
    category_id INT,
    vendor_id INT,
    is_real_time_available BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (vendor_id) REFERENCES Vendor(vendor_id)
);

CREATE TABLE Product_Option (
    option_id INT PRIMARY KEY,
    product_id INT,
    option_name VARCHAR(255), -- ex. 'Color', 'Size'
    option_value VARCHAR(255), -- ex. 'Red', 'Large'
    additional_price DECIMAL(10,2) DEFAULT 0, -- 옵션에 따른 추가 금액
    stock INT,
    FOREIGN KEY (product_id) REFERENCES Product(product_id)
);
결론
위의 설계를 통해 A고객사의 비즈니스 유연성과 성능을 확보할 수 있는 데이터 모델링을 제시했습니다. 이 데이터 모델은 실시간 판매, 입점 업체의 상품 주문, 상품의 라이프 사이클 관리, 상품 옵션 관리 등의 요구사항을 충족하도록 설계되었습니다.

#### 예약 처리 프로세스와 데이터 모델에서 발생하고 있는 동시성 이슈의 해결 방안 제시

1.  다수의 사용자가 다수의 인벤토리 예약을 하기 위한 데이터 모델의 문제점을 확인하고, 해결을 위한   방안을 제시하시오.
 <제약 조건>

•예약 처리 프로세스는 Async 한 방식으로 구현 되어야 한다

2. 다수의 사용자가 하나의 인벤토리 예약을 하려고 한다, 데이터 모델의 문제점을 확인하고 해결을 위한   방안을 제시하시오.
 <제약 조건>
•예약 처리 프로세스는 Async 한 방식으로 구현 되어야 한다   


3. 예약된 서비스에 대해 취소 프로세스를 구성하시오

###### 예약 처리 프로세스와 데이터 모델에서 발생하는 동시성 이슈를 해결하기 위한 방안을 아래와 같이 제시하겠습니다. 이를 위해 다수의 사용자가 다수의 인벤토리 또는 하나의 인벤토리를 예약하려고 할 때 발생할 수 있는 문제를 해결할 수 있는 방안을 구체적으로 검토하고 설명하겠습니다. 마지막으로 예약된 서비스에 대해 취소 프로세스를 구성하겠습니다.

1. 다수의 사용자가 다수의 인벤토리 예약을 하기 위한 데이터 모델의 문제점 및 해결 방안
문제점:

다수의 사용자가 동시에 인벤토리를 예약할 때 발생하는 데이터 일관성 문제.
동시성 문제로 인해 중복 예약이 발생하거나 예약 정보가 제대로 갱신되지 않을 수 있음.
해결 방안:

비관적 잠금(Pessimistic Locking): 데이터베이스에서 SELECT FOR UPDATE와 같은 메커니즘을 사용하여 레코드를 잠그고, 다른 트랜잭션이 동시에 접근하지 못하도록 함.
낙관적 잠금(Optimistic Locking): 각 인벤토리와 예약 정보를 버전 정보와 함께 관리하여, 업데이트가 발생할 때 버전 충돌을 감지. 이를 위해 version 컬럼을 추가합니다.
큐잉 시스템: 예약 요청을 대기열에 넣고 순차적으로 처리함으로써 동시성 이슈를 방지.
데이터 모델 예시(낙관적 잠금):

sql 

CREATE TABLE Inventory (
    inventory_id INT PRIMARY KEY,
    product_id INT,
    available_qty INT,
    version INT DEFAULT 0 -- 버전 정보 추가
);

CREATE TABLE Reservation (
    reservation_id INT PRIMARY KEY,
    inventory_id INT,
    customer_id INT,
    reservation_date DATETIME,
    status VARCHAR(50)
);
예약 처리 프로세스 (Async + 낙관적 잠금 사용):

예약 요청을 큐에 추가:

예약 요청을 비동기 메시지 큐(SQS, Kafka 등)에 추가합니다.
큐에서 처리:

예약 요청을 소비하는 워커 프로세스는 트랜잭션을 시작하고 요청을 처리합니다.
인벤토리의 version을 확인하고, 요청이 올바른 버전인지 확인한 후 예약을 진행합니다.
업데이트된 인벤토리의 version을 증가시키고, 업데이트가 성공하면 트랜잭션을 커밋합니다.
만약 버전 충돌이 일어날 경우 트랜잭션을 롤백하고 재시도합니다.
sql 

BEGIN TRANSACTION;

SELECT available_qty, version FROM Inventory WHERE inventory_id = ? FOR UPDATE;

IF available_qty > 0 THEN
    INSERT INTO Reservation (inventory_id, customer_id, reservation_date, status) 
    VALUES (?, ?, NOW(), 'Reserved');

    UPDATE Inventory
    SET available_qty = available_qty - 1,
        version = version + 1
    WHERE inventory_id = ? AND version = ?;

    COMMIT TRANSACTION;
ELSE
    ROLLBACK TRANSACTION;
END IF;

2. 다수의 사용자가 하나의 인벤토리 예약을 하려고 할 때의 문제점 및 해결 방안
문제점:

다수의 사용자가 동시에 하나의 인벤토리를 예약하려고 시도할 때 발생하는 동시성 문제.
애플리케이션 레벨에서 트랜잭션을 효율적으로 관리하지 못하면 데이터 불일치가 발생할 수 있음.
해결 방안:

비관적 잠금 또는 낙관적 잠금 사용: 하나의 인벤토리에 대한 트랜잭션 충돌을 방지하기 위해 잠금 방식을 사용합니다.
큐잉 및 비동기 처리: 큐를 통해 순차적으로 예약을 처리함으로써 동시성 문제를 해결.

3. 예약된 서비스에 대한 취소 프로세스 구성
취소 프로세스 설계:

취소 요청을 큐에 추가:

고객의 취소 요청을 비동기 메시지 큐에 추가합니다.
큐에서 취소 처리:

취소 요청을 소비하는 워커 프로세스는 트랜잭션을 시작하고 요청을 처리합니다.
취소하려는 예약을 조회하고, 해당 예약이 유효한 상태인지 확인합니다.
예약의 상태를 '취소됨'으로 갱신하고, 인벤토리의 수량을 원래대로 복구합니다.
취소 처리가 완료되면 트랜잭션을 커밋합니다.
데이터 모델:

sql 

CREATE TABLE Reservation (
    reservation_id INT PRIMARY KEY,
    inventory_id INT,
    customer_id INT,
    reservation_date DATETIME,
    status VARCHAR(50), -- 'Reserved', 'Cancelled' 등 상태 추가
    cancellation_date DATETIME
);
취소 프로세스 (Async):

취소 큐에 추가:

비동기 메시지 큐에 고객의 취소 요청을 추가합니다.
큐에서 처리:

트랜잭션 내에서 취소 요청을 처리합니다.
sql 

BEGIN TRANSACTION;

SELECT status FROM Reservation WHERE reservation_id = ? FOR UPDATE;

IF status = 'Reserved' THEN
    UPDATE Reservation
    SET status = 'Cancelled',
        cancellation_date = NOW()
    WHERE reservation_id = ?;

    UPDATE Inventory
    SET available_qty = available_qty + 1,
        version = version + 1
    WHERE inventory_id = ?;

    COMMIT TRANSACTION;
ELSE
    ROLLBACK TRANSACTION;
END IF;
이와 같은 방안을 통해 A고객사의 예약 처리 프로세스에서 발생하는 동시성 문제를 해결할 수 있으며, 비동기 방식으로 안정적이고 유연한 예약 서비스를 제공할 수 있습니다.
