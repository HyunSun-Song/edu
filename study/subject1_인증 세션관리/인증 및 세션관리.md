### A고객사 시스템의 채널 확대 및 사용자 증가에 따른 인증, 세션 관리 문제 해결 방안

<전제 조건>

•Session timeout : 30분

•중복 로그인 : 허용하지 않음

1. 사용자 증가에 따른 인증 관리 쳬계의 분담을 줄이기 위한 방안을 고안하고 설계하시오

   \- 각 서비스는 고객 증가 또는 인증 서비스의 장애 요인에 영향을 받지 않아야 한다.

2. B2B 고객을 위한 제로 트러스트 인증 방식에 대한 프로세스를 설계하시오

3. 중복 로그인 배재를 위한 방안을 제안하고 프로세스를 설계하시오

4. 인증방식의 전환에 따른 방안을 제시하고 프로세스를 설계하시오

5. 인증 불일치 또는 Session 만료에 따른 처리에 대한 UI 처리 방안을 설계하시오

**사용자 증가에 따른 인증 관리 분담을 줄이기 위한 방안:**

서비스를 분산하여 로드 밸런싱을 통해 인증 및 세션 관리 서버의 부하를 분산시킴으로써 각 서비스가 고객 증가에 영향을 받지 않도록 설계합니다. 

1. 사용자 증가에 따른 인증 관리의 분담을 줄이기 위한 방안 

1.1. 분산 아키텍처<br>로드 밸런서를 도입하여 여러 인증 서버로 트래픽을 분산시킵니다. 이를 통해 단일 서버의 과부하를 방지하고, 시스템 안정성을 높입니다. **오토스케일링 (Auto Scaling)**을 활용하여 사용자 증가에 따라 서버 자원을 동적으로 할당합니다. 이는 클라우드 환경에서 쉽게 구현할 수 있습니다. <br><br>1.2. API 게이트웨이

API 게이트웨이를 통해 인증 요청을 관리하고 조율합니다. 이를 통해 각 서비스는 독립적으로 운영되며 인증 서비스의 장애에도 영향을 받지 않습니다. <br><br>1.3. 캐싱 및 세션 스토리지 최적화

Redis와 같은 분산 캐시 시스템을 활용하여 세션 데이터를 관리합니다. 이를 통해 각 서버가 세션 데이터를 공유하여 확장성과 신뢰성을 보장합니다. 

**B2B 고객을 위한 제로 트러스트 인증 방식 프로세스:**

B2B 고객을 위한 제로 트러스트 인증 방식은 사용자의 인증을 위해 신뢰할 수 있는 외부 인증 공급업체와의 연동을 통해 안전한 인증 절차를 보장합니다. B2B 고객은 외부 인증 공급업체를 통해 토큰 또는 인증 정보를 발급받아 시스템에 접속하게 됩니다.<Br><br>2.1. 제로 트러스트 원칙 구현

검증된 신원 확인: 모든 인증 요청에서 사용자의 신원을 철저히 확인합니다. <br>최소 권한 원칙 적용: 사용자 및 애플리케이션에 최소한의 접근 권한만 부여합니다.<br>연속 인증: 지속적으로 사용자 및 디바이스 상태를 모니터링하여 이상 활동을 탐지합니다.<br><Br> 2.2. 인증 프로세스

신원 증명: 디바이스와 사용자가 신뢰할 수 있는 인증 공급업체를 통해 신원 증명을 수행합니다. <Br>인증 요청: 인증 요청 시, 백엔드 서버는 인증 공급업체 API를 호출하여 신원을 검증합니다.<br>토큰 발급: 신원이 검증된 사용자에게 JWT나 OAuth 토큰을 발급합니다. <br>자원 접근: 사용자가 자원 접근 시마다 토큰 유효성을 체크하여 접근을 승인합니다.

**중복 로그인 배재를 위한 방안 및 프로세스:**<br>

3. **중복 로그인 배제 방안 및 프로세스 설계 <br>**3.1 단일 세션 정책 사용자가 새로운 디바이스에서 로그인을 시도할 경우, 기존 세션을 무효화하고 새로운 세션을 생성합니다. 이를 위해 세션 관리 테이블에 사용자 ID와 세션 ID 매핑을 유지합니다.<br>3.2 세션 관리 프로세스 로그인 요청: 사용자가 로그인 요청을 보냅니다. <br>기존 세션 확인: 기존 세션이 존재할 경우 해당 세션을 무효화 (만료)합니다. <br>새 세션 생성: 새로운 세션을 생성하고 세션 ID를 저장합니다. <br>사용자 알림: 기존 세션이 만료되었음을 사용자에게 알립니다.

**인증방식의 전환에 따른 방안 및 프로세스:<br>**새로운 인증 방식으로의 전환 시, 사용자들에게 충분한 예고 기간을 제공하고, 기존 사용자들의 편의성을 위해 이전 방식의 인증 정보를 새로운 방식으로의 전환을 유도하는 기간을 마련하며, 유저 교육 및 테스트 기간을 제공합니다. <br>

4. **인증방식의 전환 방안 및 프로세스 설계 <br>**4.1. 단계적 전환 기존 인증 방식과 새로운 인증 방식을 병행하여 전환 기간 동안 사용자에게 적응 시간을 제공합니다. 점진적으로 새로운 인증 방식을 도입하며, 전환 완료 시 기존 방식을 완전히 폐기합니다.

4.2. 전환 프로세스 준비 단계: 새로운 인증 시스템을 개발 및 테스트하고, 사용자에게 전환 계획을 공지합니다. <br>병행 운영: 두 인증 방식을 병행하여 지원합니다. <br>사용자 교육: 새로운 인증 방식 사용법을 사용자에게 교육 및 안내합니다. <br>전체 전환: 전환 기간 종료 후, 새로운 인증 방식으로 완전히 전환합니다.

**인증 불일치 또는 Session 만료에 따른 UI 처리 방안:**

사용자에게 인증 불일치 또는 세션 만료 시에는 명확하고 사용자가 이해하기 쉬운 알림을 제공합니다. 또한, 인증 불일치로 인한 문제가 발생한 경우에는 안내 메시지를 통해 사용자가 필요한 조치를 이해하고 취할 수 있도록 UI를 설계합니다. 이러한 방안과 프로세스를 통해 사용자 증가 및 인증 관리의 문제를 개선하고, 고객 서비스 품질을 유지하며 보증할 수 있습니다.<br>

 5.1. 사용자 친화적 알림 제공

인증 불일치 또는 세션 만료 시 사용자에게 적절한 메시지를 알림창으로 표시합니다. 예시: "인증 세션이 만료되었습니다. 다시 로그인해 주세요."

5.2. 자동 로그아웃 및 재로그인 지원 세션 만료 시, 자동으로 로그아웃시키고 로그인 화면으로 리다이렉트합니다. 로그아웃 시 마무리되지 않은 작업이 있을 경우 이를 저장하거나 복구할 수 있는 옵션을 제공합니다.

5.3. 에러 페이지 디자인 인증 실패 시 사용자가 이해하기 쉽도록 에러 페이지를 디자인하여 필요한 조치를 설명합니다. 예시: "인증 과정에서 문제가 발생했습니다. 다시 시도해보세요." 이와 같은 방법들을 통해 A고객사의 시스템의 채널 확대 및 사용자 증가에 대비한 인증 및 세션 관리 문제를 효과적으로 해결할 수 있을 것입니다.

------

### 인증 및 세션관리

1. OAuth 2.0과 OpenID Connect 도입

OAuth 2.0과 OpenID Connect(OIDC)를 도입하여 인증 및 권한 관리를 분리하는 방식은 사용자의 인증과 애플리케이션의 권한 부여를 더 안전하고 간편하게 관리할 수 있습니다.

OAuth 2.0: 권한 부여 프레임워크로, 클라이언트(애플리케이션)가 자원 소유자(사용자)를 대신하여 자원 서버(예: API 서버)에 접근할 수 있도록 합니다.

OpenID Connect: OAuth 2.0 위에 구축된 인증 프로토콜로, 사용자 인증을 처리하고 사용자 정보를 안전하게 공유할 수 있습니다.

```
OAuth(OAuth2.0)란 무엇일까? 소셜로그인이 작동하는 법
```



출처: https://matamong.tistory.com/entry/OAuthOAuth20란-무엇일까-소셜로그인이-작동하는-법 [마타몽의 개발새발제발:티스토리]

[https://matamong.tistory.com/entry/OAuthOAuth20%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-%EC%86%8C%EC%85%9C%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B4-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94-%EB%B2%95](https://matamong.tistory.com/entry/OAuthOAuth20란-무엇일까-소셜로그인이-작동하는-법)

2. 복수 인증 단계(Multi-Factor Authentication, MFA)

MFA를 추가하여 보안을 강화할 수 있습니다. 이는 특히 중요한 사용자나 민감한 데이터를 다룰 때 매우 유용합니다. 예를 들어, SMS, 이메일, 또는 전용 MFA 앱을 통한 코드를 추가 입력하게 할 수 있습니다.

3. 세션 관리 개선

세션 관리는 특히 사용자 증가 시 중요한 이슈입니다. 다음과 같은 방안을 고려할 수 있습니다:

세션 타임아웃(Timeouts): 적절한 세션 타임아웃을 설정하여 오래된 세션을 자동으로 종료하는 방식.

세션 스토리지: 분산 세션 저장소(예: Redis, Memcached)를 사용하여 세션 데이터를 중앙에서 관리하므로, 여러 서버 간에 세션 상태를 일관되게 유지할 수 있습니다.

4. 토큰 기반 인증

토큰 기반 인증 방법을 활용하여 세션 관리 문제를 해결합니다.

JWT(JSON Web Tokens): 사용자의 상태를 서버에 저장하지 않는 stateless한 방식으로, 토큰을 클라이언트 측에 저장하고 주고 받음으로써 인증 상태를 관리할 수 있습니다.

토큰 만료 및 갱신: 액세스 토큰과 리프레시 토큰을 사용하여 토큰의 유효 기간을 관리하고, 일정 시간 후 또는 액세스 토큰이 만료될 때 새로운 토큰으로 갱신.

5. 중앙 인증 서비스(Identity Provider, IdP)

SAML, OAuth 등 표준 프로토콜을 사용하는 중앙 인증 서비스를 도입하여, 여러 채널에서 일관된 인증 및 권한 부여를 관리할 수 있습니다.

사례: Keycloak, Okta, Auth0 등의 IdP를 활용하여 사회적 로그인(Social Login)과 같은 기능을 제공하고 사용자의 편의성을 높일 수 있습니다.

6. 비밀번호 정책 강화

비밀번호 정책을 강화하여 보안을 더욱 단단히 합니다.

비밀번호 복잡성 요구: 대문자, 소문자, 특수문자, 숫자를 포함한 복잡한 비밀번호 사용.

비밀번호 이력 저장: 일정 기간 동안 이전 비밀번호를 사용하지 못하게 하는 기능.

7. 모니터링 및 로깅

실시간 모니터링: 로그인 시도, 실패, 비정상적인 세션 행동 등을 모니터링하여 빠르게 대응.

로깅 및 알림: 중요한 인증 및 세션 이벤트를 로깅하여 이슈가 발생할 시 알림을 받을 수 있게 설정.

이러한 방안들은 각각의 장점을 고려하여 최적의 조합으로 사용할 수 있습니다. 특히, 사용자 편의성과 보안의 균형을 맞추는 것이 중요합니다.

사용자 인증

사용자 인증(Authentication)과 권한 부여(Authorization)에 대한 이해

https://velog.io/@m_jae/Here-we-go

다중 서버환경에서의 세션 불일치 문제와 해결방법

[https://velog.io/@ddangle/%EB%8B%A4%EC%A4%91-%EC%84%9C%EB%B2%84%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B8%EC%85%98-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C%EC%99%80-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95](https://velog.io/@ddangle/다중-서버환경에서의-세션-불일치-문제와-해결방법)

------

### 세션 스토리지 서버와 Redis를 이용한 인증 및 세션 관리 방법

#### 1. **인증 및 세션 관리 개요**

- **인증(Authorization):** 사용자의 신원을 확인하고, 사용자가 적절한 권한을 가지고 있는지 확인하는 과정입니다. 일반적으로 로그인 기능을 통해 이루어집니다.
- **세션(Session) 관리:** 인증된 사용자에 대해 세션을 생성하고, 해당 세션 동안 사용자의 상태를 유지 관리하는 과정입니다. 세션은 일반적으로 사용자 ID 및 인증 정보를 포함하며, 이를 통해 사용자는 로그인 상태를 유지할 수 있습니다.

#### 2. **세션 스토리지 서버와 Redis**

- **세션 스토리지 서버:** 세션 데이터를 중앙 집중적으로 관리하는 서버입니다. 각 애플리케이션 서버가 독립적으로 세션을 관리하는 대신, 세션 스토리지 서버에 세션 데이터를 저장하여 관리합니다.
- **Redis:** 오픈 소스 인메모리 데이터 구조 저장소로, 주로 키-값(key-value) 쌍의 데이터를 저장하는 데 사용됩니다. 세션 데이터를 Redis에 저장하면 빠른 액세스가 가능하며, 세션 관리를 효율적으로 수행할 수 있습니다.

#### 3. **인증 및 세션 관리 과정**

1. **사용자 로그인 요청:**
   - 사용자가 로그인 요청을 보냅니다(사용자 ID, 패스워드).
   - 애플리케이션 서버는 사용자가 제공한 인증 정보를 확인합니다.
2. **인증 확인:**
   - 애플리케이션 서버는 데이터베이스나 인증 서버를 통해 사용자의 자격 증명이 유효한지 확인합니다.
   - 인증이 성공하면, 서버는 사용자에 대해 세션을 생성합니다.
3. **세션 생성 및 저장:**
   - 서버는 고유한 세션 ID를 생성하고, 이 세션 ID와 함께 사용자 정보를 Redis에 저장합니다.
   - Redis는 고속의 읽기/쓰기 성능을 제공하므로, 세션 관리에 적합합니다.
   - 생성된 세션 ID는 쿠키나 다른 방법으로 사용자에게 전달됩니다.
4. **세션 유지 및 확인:**
   - 사용자가 이후에 요청을 보낼 때마다 세션 ID를 함께 보냅니다.
   - 서버는 Redis에서 해당 세션 ID를 확인하여 사용자의 인증 상태를 유지합니다.
5. **세션 종료 및 로그아웃:**
   - 사용자가 로그아웃을 요청하면, 서버는 Redis에서 해당 세션 ID를 삭제하여 세션을 종료합니다.

#### 4. **세션 관리 서버 아키텍처**

```
plaintext코드 복사+-------------------------+
|       Client            |
| (웹 브라우저, 모바일 앱) |
+-----------+-------------+
            |
            | 로그인 요청 (ID, 패스워드)
            v
+-----------+-------------+
|  Application Server(s)  |
|  (Node.js, Spring 등)   |
+-----------+-------------+
            |
            | 인증 확인
            v
+-----------+-------------+
|  Authentication Server  |
|  (인증 DB/LDAP 등)       |
+-----------+-------------+
            |
            | 인증 성공 -> 세션 생성
            v
+-----------+-------------+
| Session Storage Server  |
|       (Redis)           |
+-----------+-------------+
            |
            | 세션 저장 (Session ID, 사용자 정보)
            v
+-----------+-------------+
|           Redis         |
|       (인메모리 DB)      |
+-----------+-------------+
            |
            | 세션 ID 응답
            v
+-----------+-------------+
|       Client            |
| (웹 브라우저, 모바일 앱) |
+-----------+-------------+
```

### **아키텍처 설명**

1. **Client (클라이언트):** 사용자가 로그인 요청을 보냅니다.
2. **Application Server (애플리케이션 서버):** 클라이언트의 요청을 받아서 인증을 처리합니다.
3. **Authentication Server (인증 서버):** 애플리케이션 서버로부터 전달받은 인증 정보를 기반으로 사용자의 자격을 확인합니다. 인증에 성공하면 세션을 생성합니다.
4. **Session Storage Server (세션 스토리지 서버):** Redis를 통해 세션을 관리합니다. 세션 ID와 사용자 정보를 저장하고, 클라이언트 요청 시 이를 확인합니다.
5. **Redis:** 세션 데이터를 고속으로 저장하고 조회할 수 있는 인메모리 데이터베이스입니다.

이 아키텍처는 확장성 있고, 분산 환경에서 안정적인 세션 관리를 가능하게 합니다. Redis의 높은 처리량을 활용하여 다수의 세션을 관리할 수 있으며, 중앙 집중식 세션 관리로 인한 이점을 제공할 수 있습니다.

**API** **게이트웨이 서비스 구성 개념도**<br>https://s-core.co.kr/insight/view/spring-cloud-gateway-%EA%B8%B0%EB%B0%98%EC%9D%98-api-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EA%B5%AC%EC%B6%95/

#### [[Web\] 인증과 인가 - 분산 서버에서의 세션 인증](https://sjh9708.tistory.com/45)<br>https://sjh9708.tistory.com/45

#### Session(세션)과 Token(토큰)의 차이<br>https://velog.io/@ddangle/Session%EC%84%B8%EC%85%98%EA%B3%BC-Token%ED%86%A0%ED%81%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94

#### <br>중복 로그인 방지 및 세션 연장/타임아웃이 없을 때의 관리 방안

#### 1. **중복 로그인 방지 방안**

- **단일 세션 정책 (Single Session Policy):** 사용자가 한 번 로그인하면, 해당 사용자 계정에 대해 하나의 활성 세션만 허용하는 방법입니다. 새로운 로그인이 발생하면 기존 세션을 무효화하고 새로운 세션을 활성화합니다.
- **세션 ID와 사용자 매핑:** Redis에 세션 ID와 사용자 ID를 매핑하여 저장하고, 새로운 로그인 시 기존의 세션 ID를 삭제하거나 갱신하는 방식으로 중복 로그인을 방지할 수 있습니다.
- **로그인 알림:** 새로운 장치나 위치에서 로그인이 발생하면, 사용자가 이를 인지할 수 있도록 알림을 발송하여 의심스러운 중복 로그인을 탐지할 수 있습니다.

#### 2. **세션 연장 및 타임아웃 관리 방안**

- **수동 로그아웃:** 사용자가 명시적으로 로그아웃을 요청할 때 세션을 종료합니다.
- **세션 갱신 (Session Renewal):** 사용자가 웹 애플리케이션과 상호작용할 때마다 세션의 유효기간을 연장하는 방식입니다. Redis에서 세션의 TTL(Time-To-Live)을 업데이트합니다.
- **세션 강제 종료:** 관리자가 특정 상황에서 강제로 세션을 종료할 수 있는 기능을 제공합니다.

#### 3. **관련 서버 구성도**

아래 링크를 통해 중복 로그인 방지와 관련된 서버 아키텍처 구성도를 참조할 수 있습니다. 구성도는 Redis를 활용한 세션 관리와 중복 로그인 방지 방안, 그리고 사용자 인증 서버를 포함하는 형태입니다.

이미지 파일을 직접 생성할 수는 없지만, 링크를 통해 참조하거나 아래와 같이 서버 구성도를 작성할 수 있습니다.

```
plaintext코드 복사+-------------------------+
|       Client            |
| (웹 브라우저, 모바일 앱) |
+-----------+-------------+
            |
            | 로그인 요청 (ID, 패스워드)
            v
+-----------+-------------+
|  Application Server(s)  |
|  (Node.js, Spring 등)   |
+-----------+-------------+
            |
            | 인증 확인
            v
+-----------+-------------+
|  Authentication Server  |
|  (인증 DB/LDAP 등)       |
+-----------+-------------+
            |
            | 인증 성공 -> 세션 생성
            v
+-----------+-------------+
| Session Storage Server  |
|       (Redis)           |
+-----------+-------------+
            |
            | 세션 저장 (Session ID, 사용자 정보)
            | + 사용자 ID로 세션 관리
            v
+-----------+-------------+
|           Redis         |
|  (세션 ID - 사용자 ID)   |
|  (세션 ID - TTL 설정)    |
+-----------+-------------+
            |
            | 세션 ID 응답
            v
+-----------+-------------+
|       Client            |
| (웹 브라우저, 모바일 앱) |
+-----------+-------------+
```

이 구성도는 클라이언트가 로그인할 때마다 세션이 생성되며, Redis에서 중복 세션을 관리하여 중복 로그인을 방지할 수 있는 방법을 시각적으로 표현합니다.

관련 이미지나 구성도는 Google에서 "Redis session management architecture" 혹은 "Single session policy architecture" 등의 키워드로 검색할 수 있습니다.

**세션(Session) 불일치 문제 및 해결 방법<br>**<br>https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-%EC%84%B8%EC%85%98Session-%EB%B6%88%EC%9D%BC%EC%B9%98-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EB%B2%95-%E2%B8%A2%EC%84%9C%EB%B2%84-%EB%8B%A4%EC%A4%91%ED%99%94-%ED%99%98%EA%B2%BD-%E2%B8%A5

